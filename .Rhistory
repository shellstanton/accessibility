getwd()
knitr::opts_chunk$set(echo = TRUE)
library(sf)
#remotes::install_github("r-spatial/rgee")
library(rgee)
library(mapview)
library(googledrive)
library(osmdata)
library(ggplot2)
library(raster)
library(gdistance)
library(ggplot2)
library(fasterize)
bbxmin <- 33.2
bbxmax <- 33.8
bbymin <- -11.29
bbymax <- -10.73
aoi_bbox = c(bbxmin, bbymin, bbxmax, bbymax)
q <- opq(bbox = aoi_bbox) %>%
add_osm_feature(key = 'highway') %>%
osmdata_sf()
ggplot(q$osm_lines)+geom_sf()
# Temporarily read in NDVI from folder, downloaded from GEE
ndvipath <- "./data/NDVIexample.tif")
# Temporarily read in NDVI from folder, downloaded from GEE
ndvipath <- "./data/NDVIexample.tif"
ndvi <- raster(ndvipath)
# Reclassify so that <0.35 = impassable, 0.35-0.6 = 3.5km/h, 0.6-0.7 = 2.48km/h and > 0.7 = 1.49km/h
ndviwalk_kph <- c(0.1, 3.5,  2.48, 1.49)
# Convert to m/s
ndviwalk_mps <- ndviwalk_kph/3.6
# Convert to crossing time in seconds, assuming travel along hypotenuse and pixel size is 30m
ndviwalk_secs <- 42.43/ndviwalk_mps
# Convert km/h to m/s
ndviwalk_vec <- c(-1, 0.35, ndviwalk_secs[1], 0.35, 0.6, ndviwalk_secs[2], 0.6, 0.7, ndviwalk_secs[3], 0.7, 1, ndviwalk_secs[4])
ndviwalk_mat <- matrix(ndviwalk_vec, ncol = 3, byrow = TRUE)
ndvi_assigned <- ndvi
ndvi_assigned <- reclassify(ndvi_assigned, ndviwalk_mat)
## load required packages, and install packages which are potentially missing on client computers
list.of.packages <- c("sf", "mapview", "googledrive", "osmdata", "ggplot2", "raster", "gdistance", "fasterize", "remotes", "rgdal", "stars", "geojsonio")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
## install rgee from github
remotes::install_github("r-spatial/rgee")
library(rgee)
ee_install()
knitr::opts_chunk$set(echo = TRUE)
## load required packages, and install packages which are potentially missing on client computers
list.of.packages <- c("sf", "mapview", "googledrive", "osmdata", "ggplot2", "raster", "gdistance", "fasterize", "remotes", "rgdal", "stars", "geojsonio")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
## install rgee from github
#remotes::install_github("r-spatial/rgee")
library(rgee)
ee_Initialize(drive = TRUE)
bbxmin <- 33.2
bbxmax <- 33.8
bbymin <- -11.29
bbymax <- -10.73
aoi <- ee$Geometry$Polygon(coords=list(c(bbxmin, -bbymax), c(bbxmax, bbymax), c(bbxmax, bbymin), c(bbxmin, -bbymin)))
ls8 <- ee$ImageCollection("LANDSAT/LC08/C01/T1_RT_TOA")
spatialFiltered <- ls8$filterBounds(aoi)
temporalFiltered <- spatialFiltered$filterDate('2018-06-01', '2018-09-30')
ndvilowcloud <- function(image) {
# Get a cloud score in [0, 100].
cloud <- ee$Algorithms$Landsat$simpleCloudScore(image)$select('cloud')
# Create a mask of cloudy pixels from an arbitrary threshold (20%).
mask <- cloud$lte(20)
# Compute NDVI using inbuilt function
ndvi <- image$normalizedDifference(c('B5', 'B4'))$rename('NDVI')
# Return the masked image with an NDVI band.
image$addBands(ndvi)$updateMask(mask)
}
cloudlessNDVI = temporalFiltered$map(ndvilowcloud)
medianimage <- cloudlessNDVI$median()$select('NDVI')
medNDVIaoi <- medianimage$clip(aoi)
Map$centerObject(aoi)
Map$addLayer(
eeObject=medNDVIaoi,
visParam=list(min=-1, max=1, palette=c('blue', 'white', 'green')),
name="Median NDVI"
)
medNDVIaoi
Map$centerObject(aoi)
Map$addLayer(
eeObject=medNDVIaoi)
Map$centerObject(aoi)
Map$addLayer(
eeObject=medianimage)
aoi
medNDVIaoi <- medianimage$clip(aoi)
Map$addLayer(
eeObject=medNDVIaoi,
visParam=list(min=-1, max=1, palette=c('blue', 'white', 'green')),
name="Median NDVI"
)
Map$centerObject(aoi)
Map$addLayer(
eeObject=medianimage)
aoi <- ee$Geometry$Polygon(coords=list(c(bbxmin, -bbymax), c(bbxmax, bbymax), c(bbxmax, bbymin), c(bbxmin, -bbymin)))
knitr::opts_chunk$set(echo = TRUE)
bbxmin <- 33.2
bbxmax <- 33.8
bbymin <- -11.29
bbymax <- -10.73
aoi <- ee$Geometry$Polygon(coords=list(c(bbxmin, -bbymax), c(bbxmax, bbymax), c(bbxmax, bbymin), c(bbxmin, -bbymin)))
## load required packages, and install packages which are potentially missing on client computers
list.of.packages <- c("sf", "mapview", "googledrive", "osmdata", "ggplot2", "raster", "gdistance", "fasterize", "remotes", "rgdal", "stars", "geojsonio")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
## install rgee from github
#remotes::install_github("r-spatial/rgee")
library(rgee)
aoi <- ee$Geometry$Polygon(coords=list(c(bbxmin, -bbymax), c(bbxmax, bbymax), c(bbxmax, bbymin), c(bbxmin, -bbymin)))
ee_Initialize(drive = TRUE)
ee_install()
ee_clean_pyenv()
knitr::opts_chunk$set(echo = TRUE)
## load required packages, and install packages which are potentially missing on client computers
list.of.packages <- c("sf", "mapview", "googledrive", "osmdata", "ggplot2", "raster", "gdistance", "fasterize", "remotes", "rgdal", "stars", "geojsonio")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
## install rgee from github
#remotes::install_github("r-spatial/rgee")
library(rgee)
ee_install()
## load required packages, and install packages which are potentially missing on client computers
list.of.packages <- c("sf", "mapview", "googledrive", "osmdata", "ggplot2", "raster", "gdistance", "fasterize", "remotes", "rgdal", "stars", "geojsonio")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
knitr::opts_chunk$set(echo = TRUE)
## install rgee from github
#remotes::install_github("r-spatial/rgee")
library(rgee)
ee_install()
knitr::opts_chunk$set(echo = TRUE)
## load required packages, and install packages which are potentially missing on client computers
list.of.packages <- c("sf", "mapview", "googledrive", "osmdata", "ggplot2", "raster", "gdistance", "fasterize", "remotes", "rgdal", "stars", "geojsonio")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
## install rgee from github
#remotes::install_github("r-spatial/rgee")
library(rgee)
bbxmin <- 33.2
bbxmax <- 33.8
bbymin <- -11.29
bbymax <- -10.73
aoi <- ee$Geometry$Polygon(coords=list(c(bbxmin, -bbymax), c(bbxmax, bbymax), c(bbxmax, bbymin), c(bbxmin, -bbymin)))
ee_Initialize(drive = TRUE)
ee_Initialize(drive = TRUE)
knitr::opts_chunk$set(echo = TRUE)
## load required packages, and install packages which are potentially missing on client computers
list.of.packages <- c("sf", "mapview", "googledrive", "osmdata", "ggplot2", "raster", "gdistance", "fasterize", "remotes", "rgdal", "stars", "geojsonio")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
## install rgee from github
remotes::install_github("r-spatial/rgee")
## install rgee from github
remotes::install_github("r-spatial/rgee")
brary(rgee)
library(rgee)
ee_install()
ee_Initialize(drive = TRUE)
## max and minimum values for longitude and latitude
bbxmin <- 33.2
bbxmax <- 33.8
bbymin <- -11.29
bbymax <- -10.73
aoi <- ee$Geometry$Polygon(coords=list(c(bbxmin, bbymax), c(bbxmax, bbymax), c(bbxmax, bbymin), c(bbxmin, bbymin)))
ls8 <- ee$ImageCollection("LANDSAT/LC08/C01/T1_RT_TOA")
spatialFiltered <- ls8$filterBounds(aoi)
temporalFiltered <- spatialFiltered$filterDate('2018-06-01', '2018-09-30')
ndvilowcloud <- function(image) {
# Get a cloud score in [0, 100].
cloud <- ee$Algorithms$Landsat$simpleCloudScore(image)$select('cloud')
# Create a mask of cloudy pixels from an arbitrary threshold (20%).
mask <- cloud$lte(20)
# Compute NDVI using inbuilt function
ndvi <- image$normalizedDifference(c('B5', 'B4'))$rename('NDVI')
# Return the masked image with an NDVI band.
image$addBands(ndvi)$updateMask(mask)
}
cloudlessNDVI = temporalFiltered$map(ndvilowcloud)
medianimage <- cloudlessNDVI$median()$select('NDVI')
medNDVIaoi <- medianimage$clip(aoi)
Map$centerObject(aoi)
Map$addLayer(
eeObject=medNDVIaoi,
visParam=list(min=-1, max=1, palette=c('blue', 'white', 'green')),
name="Median NDVI"
)
med_ndvi <- ee_as_raster(
image = medNDVIaoi,
region = aoi,
scale = 30,
via = 'drive'
)
writeRaster(med_ndvi,
"./data/NDVIgee",
format = "GTiff", overwrite=TRUE)
## define bounding box
aoi_bbox = c(bbxmin, bbymin, bbxmax, bbymax)
## obtain road data
q <- opq(bbox = aoi_bbox) %>%
add_osm_feature(key = 'highway') %>%
osmdata_sf()
ggplot(q$osm_lines)+geom_sf()
# Temporarily read in NDVIexample from folder, which has been directly downloaded from GEE.
# We could replace this with med_ndvi if rgee continues to be reliable.
ndvipath <- "./data/NDVIexample.tif"
ndvi <- raster(ndvipath)
# Reclassify so that <0.35 = impassable, 0.35-0.6 = 3.5km/h, 0.6-0.7 = 2.48km/h and > 0.7 = 1.49km/h
ndviwalk_kph <- c(0.1, 3.5,  2.48, 1.49)
# Convert to m/s
ndviwalk_mps <- ndviwalk_kph/3.6
# Convert to crossing time in seconds, assuming travel along hypotenuse and pixel size is 30m
ndviwalk_secs <- 42.43/ndviwalk_mps
# Convert km/h to m/s
ndviwalk_vec <- c(-1, 0.35, ndviwalk_secs[1], 0.35, 0.6, ndviwalk_secs[2], 0.6, 0.7, ndviwalk_secs[3], 0.7, 1, ndviwalk_secs[4])
ndviwalk_mat <- matrix(ndviwalk_vec, ncol = 3, byrow = TRUE)
ndvi_assigned <- ndvi
ndvi_assigned <- reclassify(ndvi_assigned, ndviwalk_mat)
# Primary = 80kph, secondary = 80kph, 'Other' road speed = 20 kph
road_vector <- c("primary", "secondary", "motorway", "trunk")
q$osm_lines$motorspeedkph <- ifelse(q$osm_lines$highway %in% road_vector, 80, 20)
q$osm_lines$motorspeedmps <- q$osm_lines$motorspeedkph/3.6
# Assume a 30m resolution cell
q$osm_lines$time_secs <- 42.43/q$osm_lines$motorspeedmps
# Convert to raster, matching up with the NDVI raster resolution and extent
# Note that the fasterize function only works with polygons, so adding a buffer to the roads of ~30m
roads.poly <- st_buffer(q$osm_line, 0.00015)
# Convert to raster, matching up with the NDVI raster resolution and extent
# Note that the fasterize function only works with polygons, so adding a buffer to the roads of ~30m
roads.poly <- st_buffer(q$osm_line, 0.00015)
sm_road_raster <- fasterize(roads.poly, ndvi_assigned, "time_secs", fun = 'min')
## merge the NDVI and the OSM, retain the minimum value (this is the quickest cell crossing time)
friction_surface_motor <- mosaic(osm_road_raster, ndvi_assigned, fun = min, tolerance = 1)
osm_road_raster <- fasterize(roads.poly, ndvi_assigned, "time_secs", fun = 'min')
#### Merge NDVI and road rasters together
The next step is to merge data for on-road and off-road trave to create one cohesive friction surface.
In areas where "road" and "off-road" cells overlap, the road values will be retained as these will be associated with the lowest cost (quickest speed).
```{r genfriction}
## merge the NDVI and the OSM, retain the minimum value (this is the quickest cell crossing time)
friction_surface_motor <- mosaic(osm_road_raster, ndvi_assigned, fun = min, tolerance = 1)
writeRaster(friction_surface_motor,
"./outputs/friction_raster_motor",
format = "GTiff", overwrite=TRUE)
healthfac <- st_read("./data/healthfacexample.shp")
# First calculate the transition matrix
# Check the transitionFunction
trans_motor <- transition(friction_surface_motor, transitionFunction = function(x){1/mean(x)}, directions=8)
healthfac <- st_read("./data/healthfacexample.shp")
# First calculate the transition matrix
# Check the transitionFunction
trans_motor <- transition(friction_surface_motor, transitionFunction = function(x){1/mean(x)}, directions=8)
# First calculate the transition matrix
# Check the transitionFunction
trans_motor <- transition(friction_surface_motor, transitionFunction = function(x){1/mean(x)}, directions=8)
# First calculate the transition matrix
# Check the transitionFunction
trans_motor <- transition(friction_surface_motor, transitionFunction = function(x){1/mean(x)}, directions=8)
knitr::opts_chunk$set(echo = TRUE)
## merge the NDVI and the OSM, retain the minimum value (this is the quickest cell crossing time)
friction_surface_motor <- mosaic(osm_road_raster, ndvi_assigned, fun = min, tolerance = 1)
writeRaster(friction_surface_motor,
"./outputs/friction_raster_motor",
format = "GTiff", overwrite=TRUE)
### Calculate shortest paths
First, add in health facility locations. Currently I'm reading in the facilities around Vwaza that have rHAT diagnostics, but will edit this to use afrimapr.
```{r, message=FALSE, results=FALSE}
healthfac <- st_read("./data/healthfacexample.shp")
## load required packages, and install packages which are potentially missing on client computers
list.of.packages <- c("sf", "mapview", "googledrive", "osmdata", "ggplot2", "raster", "gdistance", "fasterize", "remotes", "rgdal", "stars", "geojsonio")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
library(rgee)
ee_Initialize(drive = TRUE)
ee_Initialize(drive = TRUE)
library(rgee)
ee_Initialize(drive = TRUE)
## Only need to run once
ee_install()
ee_Initialize(drive = TRUE)
library(rgee)
## Only need to run once
ee_install()
knitr::opts_chunk$set(echo = TRUE)
## load required packages, and install packages which are potentially missing on client computers
list.of.packages <- c("sf", "mapview", "googledrive", "osmdata", "ggplot2", "raster", "gdistance", "fasterize", "remotes", "rgdal", "stars", "geojsonio")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
library(rgee)
ee_Initialize(drive = TRUE)
## Only need to run once
ee_install()
ee_Initialize(drive = TRUE)
## Only need to run once
ee_install()
rgee::ee_clean_pyenv()
rgee::ee_install_set_pyenv(py_path = "/Users/johnrobertarcher/Library/r-miniconda")
ee_Initialize(drive = TRUE)
knitr::opts_chunk$set(echo = TRUE)
## load required packages, and install packages which are potentially missing on client computers
list.of.packages <- c("sf", "mapview", "googledrive", "osmdata", "ggplot2", "raster", "gdistance", "fasterize", "remotes", "rgdal", "stars", "geojsonio")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
library(rgee)
ee_Initialize(drive = TRUE)
ee_Initialize(drive = TRUE)
## Only need to run once
ee_install()
knitr::opts_chunk$set(echo = TRUE)
## load required packages, and install packages which are potentially missing on client computers
list.of.packages <- c("sf", "mapview", "googledrive", "osmdata", "ggplot2", "raster", "gdistance", "fasterize", "remotes", "rgdal", "stars", "geojsonio")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
library(rgee)
ee_Initialize(drive = TRUE)
## Only need to run once
ee_install()
rgee::ee_clean_pyenv()
rgee::ee_install_set_pyenv(py_path = "/Users/johnrobertarcher/Library/r-miniconda")
knitr::opts_chunk$set(echo = TRUE)
## load required packages, and install packages which are potentially missing on client computers
list.of.packages <- c("sf", "mapview", "googledrive", "osmdata", "ggplot2", "raster", "gdistance", "fasterize", "remotes", "rgdal", "stars", "geojsonio")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only = TRUE)
library(rgee)
ee_Initialize(drive = TRUE)
## max and minimum values for longitude and latitude
bbxmin <- 33.2
bbxmax <- 33.8
bbymin <- -11.29
bbymax <- -10.73
aoi <- ee$Geometry$Polygon(coords=list(c(bbxmin, bbymax), c(bbxmax, bbymax), c(bbxmax, bbymin), c(bbxmin, bbymin)))
Read in the Landsat 8 Tier 1 dataset
```{r, eval=F}
ls8 <- ee$ImageCollection("LANDSAT/LC08/C01/T1_RT_TOA")
spatialFiltered <- ls8$filterBounds(aoi)
temporalFiltered <- spatialFiltered$filterDate('2018-06-01', '2018-09-30')
ndvilowcloud <- function(image) {
# Get a cloud score in [0, 100].
cloud <- ee$Algorithms$Landsat$simpleCloudScore(image)$select('cloud')
# Create a mask of cloudy pixels from an arbitrary threshold (20%).
mask <- cloud$lte(20)
# Compute NDVI using inbuilt function
ndvi <- image$normalizedDifference(c('B5', 'B4'))$rename('NDVI')
# Return the masked image with an NDVI band.
image$addBands(ndvi)$updateMask(mask)
}
cloudlessNDVI = temporalFiltered$map(ndvilowcloud)
medianimage <- cloudlessNDVI$median()$select('NDVI')
medNDVIaoi <- medianimage$clip(aoi)
Map$centerObject(aoi)
Map$addLayer(
eeObject=medNDVIaoi,
visParam=list(min=-1, max=1, palette=c('blue', 'white', 'green')),
name="Median NDVI"
)
med_ndvi <- ee_as_raster(
image = medNDVIaoi,
region = aoi,
scale = 30,
via = 'drive'
)
writeRaster(med_ndvi,
"./data/NDVIgee",
format = "GTiff", overwrite=TRUE)
## define bounding box
aoi_bbox = c(bbxmin, bbymin, bbxmax, bbymax)
## obtain road data
q <- opq(bbox = aoi_bbox) %>%
add_osm_feature(key = 'highway') %>%
osmdata_sf()
ggplot(q$osm_lines)+geom_sf()
# Temporarily read in NDVIexample from folder, which has been directly downloaded from GEE.
# We could replace this with med_ndvi if rgee continues to be reliable.
ndvipath <- "./data/NDVIexample.tif"
ndvi <- raster(ndvipath)
# Reclassify so that <0.35 = impassable, 0.35-0.6 = 3.5km/h, 0.6-0.7 = 2.48km/h and > 0.7 = 1.49km/h
ndviwalk_kph <- c(0.1, 3.5,  2.48, 1.49)
# Convert to m/s
ndviwalk_mps <- ndviwalk_kph/3.6
# Convert to crossing time in seconds, assuming travel along hypotenuse and pixel size is 30m
ndviwalk_secs <- 42.43/ndviwalk_mps
# Convert km/h to m/s
ndviwalk_vec <- c(-1, 0.35, ndviwalk_secs[1], 0.35, 0.6, ndviwalk_secs[2], 0.6, 0.7, ndviwalk_secs[3], 0.7, 1, ndviwalk_secs[4])
ndviwalk_mat <- matrix(ndviwalk_vec, ncol = 3, byrow = TRUE)
ndvi_assigned <- ndvi
ndvi_assigned <- reclassify(ndvi_assigned, ndviwalk_mat)
# Primary = 80kph, secondary = 80kph, 'Other' road speed = 20 kph
road_vector <- c("primary", "secondary", "motorway", "trunk")
q$osm_lines$motorspeedkph <- ifelse(q$osm_lines$highway %in% road_vector, 80, 20)
q$osm_lines$motorspeedmps <- q$osm_lines$motorspeedkph/3.6
# Assume a 30m resolution cell
q$osm_lines$time_secs <- 42.43/q$osm_lines$motorspeedmps
# Convert to raster, matching up with the NDVI raster resolution and extent
# Note that the fasterize function only works with polygons, so adding a buffer to the roads of ~30m
roads.poly <- st_buffer(q$osm_line, 0.00015)
osm_road_raster <- fasterize(roads.poly, ndvi_assigned, "time_secs", fun = 'min')
## merge the NDVI and the OSM, retain the minimum value (this is the quickest cell crossing time)
friction_surface_motor <- mosaic(osm_road_raster, ndvi_assigned, fun = min, tolerance = 1)
writeRaster(friction_surface_motor,
"./outputs/friction_raster_motor",
format = "GTiff", overwrite=TRUE)
healthfac <- st_read("./data/healthfacexample.shp")
healthfac
# First calculate the transition matrix
# Check the transitionFunction
trans_motor <- transition(friction_surface_motor, transitionFunction = function(x){1/mean(x)}, directions=8)
# First calculate the transition matrix
# Check the transitionFunction
trans_motor <- transition(friction_surface_motor, transitionFunction = function(x){1/mean(x)}, directions=8)
